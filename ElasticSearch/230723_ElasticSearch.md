# Documents and Indices

Elasticsearch는 분산화된 document 저장소입니다. 관계형 데이터와 달리, Elasticsearch는 JSON 문서의 저장합니다. 만약 여러 개의 Elasticsearch 노드를 클러스터에 있다면, 저장된 documents 들은 클러스터 내에 분산되어 어느 노드에서든 바로 접근할 수 있습니다.

Document가 저장되면, 1초 이내에 인덱스화 되고 검색 기능을 사용할 수 있게 됩니다. Elasticsearch는 inverted index라고 불리우는 자료구조를 사용하는데, 이를 통해 매우 빠른 텍스트 검색을 지원합니다. Inverted index는 어떤 문서에서든 발견된 모든 단어의 리스트를 갖고 있고 각 단어가 어느 문서에서 찾을 수 있는지 밝힙니다.

Elasticsearch는 또한 문서에 등장하는 각각의 다른 필드에 대해서 어떻게 다뤄야하는지 명백하게 지정하지 않더라도 인덱스 될 수 있습니다. Dynamic mapping을 사용하면, Elsticsearch는 자동으로 감지해서 인덱스에 새 필드를 추가합니다. 이와 같은 기본 동작을 통해 데이터를 더 쉽게 인덱싱하고 둘러볼 수 있습니다.
참/거짓, 부동 소수점, 정수형, 날짜형, 문자형 등의 적절한 타입으로 Elasticsearch가 매핑합니다.

궁극적으로 유저가 자신의 데이터에 대해서 어떻게 사용하고 싶은지 더 잘 알기 때문에 유저가 스스로 룰을 정하고 dynamic mapping을 컨트롤할 수 있습니다.

가끔은 같은 필드라고 해도 다른 목적에 의해 다르게 인덱스하는 것이 나을 때가 있습니다.

# 검색과 분석

Elasticsearch의 진짜 힘은 쉽게 모든 종류의 검색 기능을 접근할 수 있다는 데 있습니다.

Elasticsearch는 클러스터를 관리하고 데이터를 인덱싱, 검색할 수 있는 단순하고 일관적인 API를 제공하고 있습니다.

## 데이터 검색

Elasticsearch API는 구조적 쿼리, full text 쿼리, 두 개를 섞은 복잡한 쿼리를 지원합니다. 구조적 쿼리는 SQL에서 사용하던 쿼리와 유사합니다. 예를 들어서 사용자는 gender와 age 필드를 employee 인덱스에서 검색할 수 있고, hire_date 필드로 정렬할 수도 있습니다.
Full text 쿼리는 쿼리문에 맞는 모든 문서를 찾고 관계성에 따라 정렬된 문서들을 반환하는 것입니다.

개별 단어를 검색하는 것을 넘어 구문 검색, 유사도 검색 그리고 prefix 검색 그리고 자동완성 기능도 제공합니다.

Elasticsearch는 지리 데이터나 수리적 데이터도 최적화된 자료 구조로 인덱스하여 좋은 성능의 쿼리를 제공합니다.

이러한 기능들을 JSON style 쿼리 언어로 접근할 수 있고 Elasticsearch 내부에서 SQL 스타일 쿼리를 구축하거나 데이터를 종합해서 볼 수 있습니다. JDBC나 ODBC 드라이버를 사용해서 더 많은 범위에 제 3의 어플리케이션에서 SQL을 통해 Elasticsearch와 상호작용할 수 있습니다.

## 데이터 분석

Elasticsearch aggregation을 사용하면 데이터에 관한 복잡한 요약을 볼 수 있고 주요 지표, 패턴, 그리고 트렌드에 관한 인사이트를 얻을 수 있습니다.

Aggregation은 검색과 같은 자료구조를 사용하기 때문에 매우 빠릅니다. 덕분에 실시간으로 데이터를 분석하고 시각화할 수 있습니다. 데이터가 바뀌면 리포트와 대시보드도 최신 정보로 업데이트가 됩니다.

Aggregation은 검색 요청과 더불어 작동합니다. 그래서 document를 검색하고 결과를 필터링하는 일도 동시에 같은 데이터를 하나의 요청으로 수행할 수 있습니다. 

## 확장성과 회복 탄력성: 클러스터, 노드 그리고 샤드

Elasticsearch는 언제나 사용자의 요구에 맞춰 확장할 수 있도록 만들어졌습니다. 용량을 늘리기 위해서는 클러스터에 노드를 추가하면 Elastic search가 자동으로 데이터와 쿼리 작업량을 가용 가능한 노드로 분산화합니다. Elasticsearch는 여러 개의 노드가 있는 클러스터들을 어떻게 균형잡아야하는지 잘 알고 있습니다.

Elasticsearch 인덱스는 하나 이상의 물리적 샤드의 논리적 그루핑입니다. 각각의 샤드는 사실 스스로를 포함하고 있는 인덱스입니다. 여러 개의 샤드에 인덱스에 있는 document를 분산시킴으로서, Elasticsearch는 여러 번 겹쳐지는 것을 보장합니다. 이를 통해 하드웨어 실패로부터 보호하고 클러스터에 노드가 추가 되었을 때 쿼리 용량을 늘립니다.

샤드에는 두 가지 종류가 있습니다. 인덱스의 가각의 문서는 하나의 primary 샤드에 속해있고, 레프리카 샤드는 primary shard의 복제입니다. 레플리카를 이용해서 하드웨어 문제나 읽기 요청등의 용량을 더 늘릴 수 있습니다.

인덱스 안에 샤드의 개수는 인덱스가 만들어 지던 때 고정되고 레플리카 샤드의 개수는 다른 동작에 영향을 주지 않고 언제든 바뀔 수 있습니다.

샤드의 크기와 몇 개의 프라이머리 샤드를 하나의 인덱스에 구성할 지에 대해서 trade-off가 있기 때문에 잘 생각해야 한다.

샤드가 많아지면 인덱스를 유지하는 오버해드가 늘어날 것이고 샤드의 크기를 키우면 클러스터를 리밸런싱하는데 더 많은 시간이 걸립니다.

작은 샤드를 사용하면 빠르지만 더 많은 쿼리문과 함께 오버헤드가 늘어납니다.

클러스트의 노드는 서로 신뢰할 수 있는 좋은 연결이 필요합니다. 더 좋은 연결을 지원하기 위해 노드를 같은 데이터 센터 혹은 근방의 데이터 선테에 이중화를 합니다. 하지만,가용성을 높이기 위해서는 단일 포인트 실패를 피해야 합니다. 한 쪽이 문제가 발생했을 때 다른 곳에 
시스템을 장악해야합니다. 이것은 Cross culster replication으로 가능합니다

프라이머리 클러스터에서의 인덱스들을 자동으로 두번째 외부 클러스터에 동기화해서  hot backup 을 할 수 있다. 또 CCR을 사용자와 지리적으로 가까운 곳에서 읽기 요청을 서브할 수 있도록 수행하기도 한다.

Kibana를 이용하면 Elastic search의 보안, 모니터링 관리 기능들을 이용할 수 있습니다.
데이터 롤업이나 인덱스 라이프사이클 관리를 통해 사용자가 똑똑하게 데이터를 시간이 흘러도 관리할 수 있게 합니다.

